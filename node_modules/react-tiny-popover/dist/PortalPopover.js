"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var react_dom_1 = require("react-dom");
var util_1 = require("./util");
var PortalPopover = /** @class */ (function (_super) {
    __extends(PortalPopover, _super);
    function PortalPopover() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.target = null;
        _this.popoverContainerDiv = null;
        _this.willUnmount = false;
        _this.willMount = false;
        _this.positionOrder = null;
        _this.targetPositionIntervalHandler = null;
        _this.isBoundaryViolation = function (rect, position, padding) {
            return (position === 'top' && rect.top < padding) ||
                (position === 'left' && rect.left < padding) ||
                (position === 'right' && rect.left + rect.width > window.innerWidth - padding) ||
                (position === 'bottom' && rect.top + rect.height > window.innerHeight - padding);
        };
        _this.onClick = function (e) {
            var _a = _this.props, onClickOutside = _a.onClickOutside, isOpen = _a.isOpen;
            if (!_this.willUnmount && !_this.willMount && !_this.popoverContainerDiv.contains(e.target) && !_this.target.contains(e.target) && onClickOutside && isOpen) {
                onClickOutside(e);
            }
        };
        return _this;
    }
    PortalPopover.prototype.componentWillMount = function () {
        this.willUnmount = false;
        this.willMount = true;
        this.positionOrder = this.getPositionPriorityOrder(this.props.position);
    };
    PortalPopover.prototype.componentDidMount = function () {
        var _this = this;
        this.target = react_dom_1.findDOMNode(this);
        window.setTimeout(function () { return _this.willMount = false; });
    };
    PortalPopover.prototype.componentWillUnmount = function () {
        this.willUnmount = true;
        this.removePopoverContainerDiv();
    };
    PortalPopover.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.position !== this.props.position) {
            this.positionOrder = this.getPositionPriorityOrder(nextProps.position);
        }
    };
    PortalPopover.prototype.componentWillUpdate = function (nextProps) {
        var nextIsOpen = nextProps.isOpen;
        var currIsOpen = this.props.isOpen;
        if (!nextIsOpen && currIsOpen) {
            this.removePopoverContainerDiv();
        }
    };
    PortalPopover.prototype.componentDidUpdate = function () {
        if (this.props.isOpen) {
            this.positionPopover();
        }
    };
    PortalPopover.prototype.render = function () {
        var _a = this.props, children = _a.children, isOpen = _a.isOpen;
        return (React.createElement(React.Fragment, null,
            children,
            isOpen && this.createPopoverPortal()));
    };
    PortalPopover.prototype.positionPopover = function () {
        var _this = this;
        var finalContentRenderState = {
            align: this.props.align,
            position: this.positionOrder[0],
            nudgedLeft: 0,
            nudgedTop: 0,
            popoverRect: util_1.Constants.EMPTY_CLIENT_RECT,
            targetRect: util_1.Constants.EMPTY_CLIENT_RECT,
        };
        var hasValidPosition = this.positionOrder.some(function (position) {
            var targetRect = _this.target.getBoundingClientRect();
            var popoverRect = _this.popoverContainerDiv.firstChild.getBoundingClientRect();
            var _a = _this.getLocationForPosition(position, targetRect, popoverRect), top = _a.top, left = _a.left;
            var width = popoverRect.width, height = popoverRect.height;
            var newPopoverRect = { top: top, left: left, width: width, height: height };
            if (_this.isBoundaryViolation(newPopoverRect, position, _this.props.padding)) {
                return false;
            }
            var _b = _this.getNudgedPopoverPosition(newPopoverRect), nudgedTop = _b.top, nudgedLeft = _b.left;
            _this.popoverContainerDiv.style.top = nudgedTop + "px";
            _this.popoverContainerDiv.style.left = nudgedLeft + "px";
            _this.popoverContainerDiv.style.opacity = '1';
            finalContentRenderState = __assign({}, finalContentRenderState, { nudgedTop: nudgedTop,
                nudgedLeft: nudgedLeft,
                position: position, popoverRect: newPopoverRect, targetRect: targetRect });
            return true;
        });
        if (!hasValidPosition) {
            this.removePopoverContainerDiv();
        }
        else {
            this.setState({});
        }
    };
    PortalPopover.prototype.createPopoverPortal = function () {
        if (!this.popoverContainerDiv || !this.popoverContainerDiv.parentNode) {
            var transitionDuration = this.props.transitionDuration;
            this.popoverContainerDiv = this.createContainer();
            window.document.body.appendChild(this.popoverContainerDiv);
            window.addEventListener('click', this.onClick);
        }
        var _a = this.props, content = _a.content, align = _a.align;
        var getContent = function (args) {
            return typeof content === 'function'
                ? content(args)
                : content;
        };
        return react_dom_1.createPortal(getContent({
            position: this.positionOrder[0],
            align: align,
            nudgedLeft: 0,
            nudgedTop: 0,
            popoverRect: util_1.Constants.EMPTY_CLIENT_RECT,
            targetRect: util_1.Constants.EMPTY_CLIENT_RECT,
        }), this.popoverContainerDiv);
    };
    PortalPopover.prototype.createContainer = function () {
        var _a = this.props, containerStyle = _a.containerStyle, containerClassName = _a.containerClassName, transitionDuration = _a.transitionDuration;
        var container = window.document.createElement('div');
        container.style.overflow = 'hidden';
        if (containerStyle) {
            Object.keys(containerStyle).forEach(function (key) { return container.style[key] = containerStyle[key]; });
        }
        container.className = containerClassName;
        container.style.position = 'absolute';
        container.style.top = '0';
        container.style.left = '0';
        container.style.opacity = '0';
        container.style.transition = "opacity " + (transitionDuration || util_1.Constants.FADE_TRANSITION) + "s";
        return container;
    };
    PortalPopover.prototype.removePopoverContainerDiv = function () {
        var _this = this;
        if (this.popoverContainerDiv && this.popoverContainerDiv.parentElement !== null) {
            var transitionDuration = this.props.transitionDuration;
            this.popoverContainerDiv.style.opacity = '0';
            var remove = function () {
                if (_this.willUnmount || !_this.props.isOpen || !_this.popoverContainerDiv.parentNode) {
                    window.clearInterval(_this.targetPositionIntervalHandler);
                    window.removeEventListener('click', _this.onClick);
                    _this.targetPositionIntervalHandler = null;
                    if (_this.popoverContainerDiv.parentNode) {
                        _this.popoverContainerDiv.parentNode.removeChild(_this.popoverContainerDiv);
                    }
                }
            };
            if (!this.willUnmount) {
                window.setTimeout(remove, (transitionDuration || util_1.Constants.FADE_TRANSITION) * 1000);
            }
            else {
                remove();
            }
        }
    };
    PortalPopover.prototype.getPositionPriorityOrder = function (position) {
        if (position && typeof position !== 'string') {
            if (util_1.Constants.DEFAULT_POSITIONS.every(function (defaultPosition) { return position.find(function (p) { return p === defaultPosition; }) !== undefined; })) {
                return util_1.arrayUnique(position);
            }
            else {
                var remainingPositions = util_1.Constants.DEFAULT_POSITIONS.filter(function (defaultPosition) { return position.find(function (p) { return p === defaultPosition; }) === undefined; });
                return util_1.arrayUnique(position.concat(remainingPositions));
            }
        }
        else if (position && typeof position === 'string') {
            var remainingPositions = util_1.Constants.DEFAULT_POSITIONS.filter(function (defaultPosition) { return defaultPosition !== position; });
            return util_1.arrayUnique([position].concat(remainingPositions));
        }
    };
    PortalPopover.prototype.getLocationForPosition = function (position, newTargetRect, popoverRect) {
        var _a = this.props, padding = _a.padding, align = _a.align;
        var targetMidX = newTargetRect.left + (newTargetRect.width / 2);
        var targetMidY = newTargetRect.top + (newTargetRect.height / 2);
        var top;
        var left;
        switch (position) {
            case 'top':
                top = newTargetRect.top - popoverRect.height - padding;
                left = targetMidX - (popoverRect.width / 2);
                if (align === 'start') {
                    left = newTargetRect.left;
                }
                if (align === 'end') {
                    left = newTargetRect.right - popoverRect.width;
                }
                break;
            case 'left':
                top = targetMidY - (popoverRect.height / 2);
                left = newTargetRect.left - padding - popoverRect.width;
                if (align === 'start') {
                    top = newTargetRect.top;
                }
                if (align === 'end') {
                    top = newTargetRect.bottom - popoverRect.height;
                }
                break;
            case 'bottom':
                top = newTargetRect.bottom + padding;
                left = targetMidX - (popoverRect.width / 2);
                if (align === 'start') {
                    left = newTargetRect.left;
                }
                if (align === 'end') {
                    left = newTargetRect.right - popoverRect.width;
                }
                break;
            case 'right':
                top = targetMidY - (popoverRect.height / 2);
                left = newTargetRect.right + padding;
                if (align === 'start') {
                    top = newTargetRect.top;
                }
                if (align === 'end') {
                    top = newTargetRect.bottom - popoverRect.height;
                }
                break;
        }
        return { top: top, left: left };
    };
    PortalPopover.prototype.getNudgedPopoverPosition = function (_a) {
        var top = _a.top, left = _a.left, width = _a.width, height = _a.height;
        var padding = this.props.windowBorderPadding;
        top = top < padding ? padding : top;
        top = top + height > window.innerHeight - padding ? window.innerHeight - padding - height : top;
        left = left < padding ? padding : left;
        left = left + width > window.innerWidth - padding ? window.innerWidth - padding - width : left;
        return { top: top, left: left };
    };
    PortalPopover.defaultProps = {
        padding: util_1.Constants.DEFAULT_PADDING,
        windowBorderPadding: util_1.Constants.DEFAULT_WINDOW_PADDING,
        position: ['top', 'right', 'left', 'bottom'],
        align: 'center',
        containerClassName: util_1.Constants.POPOVER_CONTAINER_CLASS_NAME,
    };
    return PortalPopover;
}(React.Component));
exports.PortalPopover = PortalPopover;
//# sourceMappingURL=PortalPopover.js.map