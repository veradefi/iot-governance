{"version":3,"sources":["main.es2015.js"],"names":[],"mappings":"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","file":"main.es5.js","sourcesContent":["// @flow\nimport syntaxAsyncFunctions from 'babel-plugin-syntax-async-functions';\nimport type {NodePath} from 'babel-traverse';\nimport traverse from 'babel-traverse';\nimport nameFunction from 'babel-helper-function-name';\nimport template from 'babel-template';\n\nconst FUNCTION_TYPES = [\n\t'FunctionDeclaration',\n\t'FunctionExpression',\n\t'ArrowFunctionExpression',\n];\n\nconst BUILD_WRAPPER = template(`\n\t(() => {\n\t\tvar REF = FUNCTION;\n\t\treturn function NAME(PARAMS) {\n\t\t\treturn REF.apply(this, arguments);\n\t\t};\n\t})\n`);\n\nconst NAMED_BUILD_WRAPPER = template(`\n\t(() => {\n\t\tvar REF = FUNCTION;\n\t\tfunction NAME(PARAMS) {\n\t\t\treturn REF.apply(this, arguments);\n\t\t}\n\t\treturn NAME;\n\t})\n`);\n\nexport default function asyncToBluebird(pluginArg: any) {\n\tconst {types: t} = pluginArg;\n\n\tfunction classOrObjectMethod(path: NodePath, state: any, hasAwait: boolean) {\n\t\tconst {node} = path;\n\t\tconst {body} = node;\n\n\t\tnode.async = false;\n\t\tnode.generator = false;\n\n\t\tconst container = t.functionExpression(null, [], t.blockStatement(body.body), true);\n\t\tcontainer.shadow = true;\n\t\tcontainer.generator = hasAwait;\n\t\tconst bbImport = state.addImport('bluebird', hasAwait ? 'coroutine' : 'method');\n\t\tbody.body = [\n\t\t\tt.returnStatement(\n\t\t\t\tt.callExpression(\n\t\t\t\t\tt.callExpression(\n\t\t\t\t\t\tbbImport,\n\t\t\t\t\t\t[container]\n\t\t\t\t\t),\n\t\t\t\t\t[]\n\t\t\t\t)\n\t\t\t),\n\t\t];\n\t}\n\n\tfunction plainFunction(path: NodePath, state: any, hasAwait: boolean) {\n\t\tconst {node} = path;\n\t\tconst isDeclaration = path.isFunctionDeclaration();\n\t\tconst asyncFnId = node.id;\n\n\t\tlet wrapper = BUILD_WRAPPER;\n\t\tif (path.isArrowFunctionExpression()) path.arrowFunctionToShadowed();\n\t\telse if (!isDeclaration && asyncFnId) wrapper = NAMED_BUILD_WRAPPER;\n\n\t\tnode.async = false;\n\t\tnode.generator = hasAwait;\n\n\t\tnode.id = null;\n\n\t\tif (isDeclaration) node.type = 'FunctionExpression';\n\n\t\tconst bbImport = state.addImport('bluebird', hasAwait ? 'coroutine' : 'method');\n\t\tconst built = t.callExpression(bbImport, [node]);\n\t\tconst container = wrapper({\n\t\t\tNAME: asyncFnId,\n\t\t\tREF: path.scope.generateUidIdentifier('ref'),\n\t\t\tFUNCTION: built,\n\t\t\tPARAMS: node.params.map(() => path.scope.generateUidIdentifier('x')),\n\t\t}).expression;\n\n\t\tif (isDeclaration) {\n\t\t\tconst declar = t.variableDeclaration('let', [\n\t\t\t\tt.variableDeclarator(\n\t\t\t\t\tt.identifier(asyncFnId.name),\n\t\t\t\t\tt.callExpression(container, [])\n\t\t\t\t),\n\t\t\t]);\n\t\t\tdeclar._blockHoist = true;\n\n\t\t\tpath.replaceWith(declar);\n\t\t} else {\n\t\t\tconst retFunction = container.body.body[1].argument;\n\t\t\tif (!asyncFnId) {\n\t\t\t\tnameFunction({\n\t\t\t\t\tnode: retFunction,\n\t\t\t\t\tparent: path.parent,\n\t\t\t\t\tscope: path.scope,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!retFunction || retFunction.id || node.params.length) {\n\t\t\t\t// we have an inferred function id or params so we need this wrapper\n\t\t\t\tpath.replaceWith(t.callExpression(container, []));\n\t\t\t} else {\n\t\t\t\t// we can omit this wrapper as the conditions it protects for do not apply\n\t\t\t\tpath.replaceWith(built);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tinherits: syntaxAsyncFunctions,\n\t\tvisitor: {\n\t\t\tFunction(path: NodePath, state: any) {\n\t\t\t\tconst {node, scope} = path;\n\t\t\t\tif (!node.async || node.generator) return;\n\t\t\t\tconst hasAwait = traverse.hasType(node.body, scope, 'AwaitExpression', FUNCTION_TYPES);\n\n\t\t\t\ttraverse(node, {\n\t\t\t\t\tblacklist: FUNCTION_TYPES,\n\n\t\t\t\t\tAwaitExpression(path2: NodePath) {\n\t\t\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\t\t\tpath2.node.type = 'YieldExpression';\n\t\t\t\t\t\tpath2.node.argument = t.callExpression(\n\t\t\t\t\t\t\tstate.addImport('bluebird', 'resolve'),\n\t\t\t\t\t\t\t[path2.node.argument]\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t}, scope);\n\n\t\t\t\tconst isClassOrObjectMethod = path.isClassMethod() || path.isObjectMethod();\n\t\t\t\t(isClassOrObjectMethod ? classOrObjectMethod : plainFunction)(path, state, hasAwait);\n\t\t\t},\n\t\t},\n\t};\n}\n"]}